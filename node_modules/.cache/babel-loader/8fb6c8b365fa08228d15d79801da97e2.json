{"ast":null,"code":"import * as THREE from \"three\";\nimport alphaTexture from \"../../../assets/textures/stripes_gradient.jpg\";\nimport * as OBJLoader from \"three-obj-loader\";\nimport model from \"../../../assets/models/dummy.obj\";\nvar loader = new THREE.OBJLoader();\nOBJLoader(THREE);\nvar group = new THREE.Group();\nexport default (function (scene, geo, model) {\n  // const subjectGeometry = deformGeometry(geo);\n  var subjectGeometry = geo;\n  var subjectMaterial = new THREE.MeshStandardMaterial({\n    color: \"#000\",\n    transparent: true,\n    side: THREE.DoubleSide,\n    alphaTest: 0.5\n  });\n  subjectMaterial.alphaMap = new THREE.TextureLoader().load(alphaTexture);\n  subjectMaterial.alphaMap.magFilter = THREE.NearestFilter;\n  subjectMaterial.alphaMap.wrapT = THREE.RepeatWrapping;\n  subjectMaterial.alphaMap.repeat.y = 1;\n  var subjectMesh = new THREE.Mesh(subjectGeometry, subjectMaterial);\n  var subjectWireframe = new THREE.LineSegments(new THREE.EdgesGeometry(subjectGeometry), new THREE.LineBasicMaterial()); //upload a model\n\n  group.add(subjectMesh);\n  group.add(subjectWireframe);\n  scene.add(group);\n  group.rotation.z = 6 * Math.PI;\n  var speed = 0.02;\n  var textureOffsetSpeed = 0.02; // function deformGeometry(geometry) {\n  //     for (let i=0; i<geometry.vertices.length; i+=2) {\n  //         const scalar = 1 + Math.random()*0.8;\n  //         geometry.vertices[i].multiplyScalar(scalar)\n  //     }\n  //     return geometry;\n  // }\n\n  function update(time) {\n    var angle = time * speed;\n    group.rotation.y = angle;\n    subjectMaterial.alphaMap.offset.y = 0.55 + time * textureOffsetSpeed;\n    subjectWireframe.material.color.setHSL(Math.sin(angle * 2), 0.5, 0.5);\n    var scale = (Math.sin(angle * 8) + 6.4) / 5;\n    subjectWireframe.scale.set(scale, scale, scale);\n  }\n\n  return {\n    update: update\n  };\n});\n\nvar loadObj = function loadObj() {\n  loader.load( // resource URL\n  model, // called when resource is loaded\n  function (object) {\n    console.log(object);\n    group.add(object);\n  }, // called when loading is in progresses\n  function (xhr) {\n    console.log(xhr.loaded / xhr.total * 100 + \"% loaded\");\n  }, // called when loading has errors\n  function (error) {\n    console.log(\"An error happened\");\n  });\n};","map":{"version":3,"sources":["/var/www/html/learning-react/react-threeJS/src/components/canvas/threejs/SceneSubject.js"],"names":["THREE","alphaTexture","OBJLoader","model","loader","group","Group","scene","geo","subjectGeometry","subjectMaterial","MeshStandardMaterial","color","transparent","side","DoubleSide","alphaTest","alphaMap","TextureLoader","load","magFilter","NearestFilter","wrapT","RepeatWrapping","repeat","y","subjectMesh","Mesh","subjectWireframe","LineSegments","EdgesGeometry","LineBasicMaterial","add","rotation","z","Math","PI","speed","textureOffsetSpeed","update","time","angle","offset","material","setHSL","sin","scale","set","loadObj","object","console","log","xhr","loaded","total","error"],"mappings":"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","sourcesContent":["import * as THREE from \"three\";\nimport alphaTexture from \"../../../assets/textures/stripes_gradient.jpg\";\n\nimport * as OBJLoader from \"three-obj-loader\";\nimport model from \"../../../assets/models/dummy.obj\";\n\n\nconst loader = new THREE.OBJLoader();\nOBJLoader(THREE);\nconst group = new THREE.Group();\n\n\n\n\n\nexport default (scene, geo, model) => {\n\n  // const subjectGeometry = deformGeometry(geo);\n  const subjectGeometry = geo;\n  const subjectMaterial = new THREE.MeshStandardMaterial({\n    color: \"#000\",\n    transparent: true,\n    side: THREE.DoubleSide,\n    alphaTest: 0.5\n  });\n  subjectMaterial.alphaMap = new THREE.TextureLoader().load(alphaTexture);\n  subjectMaterial.alphaMap.magFilter = THREE.NearestFilter;\n  subjectMaterial.alphaMap.wrapT = THREE.RepeatWrapping;\n  subjectMaterial.alphaMap.repeat.y = 1;\n\n  const subjectMesh = new THREE.Mesh(subjectGeometry, subjectMaterial);\n\n  const subjectWireframe = new THREE.LineSegments(\n    new THREE.EdgesGeometry(subjectGeometry),\n    new THREE.LineBasicMaterial()\n  );\n\n  //upload a model\n\n  group.add(subjectMesh);\n  group.add(subjectWireframe);\n  scene.add(group);\n\n  group.rotation.z = 6 * Math.PI;\n\n  const speed = 0.02;\n  const textureOffsetSpeed = 0.02;\n\n  // function deformGeometry(geometry) {\n  //     for (let i=0; i<geometry.vertices.length; i+=2) {\n  //         const scalar = 1 + Math.random()*0.8;\n  //         geometry.vertices[i].multiplyScalar(scalar)\n  //     }\n\n  //     return geometry;\n  // }\n\n  function update(time) {\n    const angle = time * speed;\n\n    group.rotation.y = angle;\n\n    subjectMaterial.alphaMap.offset.y = 0.55 + time * textureOffsetSpeed;\n\n    subjectWireframe.material.color.setHSL(Math.sin(angle * 2), 0.5, 0.5);\n\n    const scale = (Math.sin(angle * 8) + 6.4) / 5;\n    subjectWireframe.scale.set(scale, scale, scale);\n  }\n\n  return {\n    update\n  };\n};\n\n\nconst loadObj = () => {\n    loader.load(\n       // resource URL\n       model,\n       // called when resource is loaded\n       object => {\n         console.log(object);\n         group.add(object)\n       },\n       // called when loading is in progresses\n       xhr => {\n         console.log((xhr.loaded / xhr.total) * 100 + \"% loaded\");\n       },\n       // called when loading has errors\n       error => {\n         console.log(\"An error happened\");\n       }\n     );\n   };"]},"metadata":{},"sourceType":"module"}